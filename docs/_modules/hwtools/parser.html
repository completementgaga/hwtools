
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hwtools.parser &#8212; hwTools 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for hwtools.parser</h1><div class="highlight"><pre>
<span></span><span class="c1"># hwTools -- Computer aided handwritten text parsing.</span>
<span class="c1">#</span>
<span class="c1"># (C) 2023 Gaël Cousin.</span>
<span class="c1"># You may use and distribute this program under the terms of MongoDB&#39;s</span>
<span class="c1"># Server Side Public License Version 1, a copy of which you should have received</span>
<span class="c1"># along with this program. Otherwise, see &lt;https://spdx.org/licenses/SSPL-1.0.html&gt;</span>
<span class="c1"># or &lt;https://www.mongodb.com/licensing/server-side-public-license&gt;.</span>
<span class="c1">#</span>
<span class="c1"># Gaël Cousin can be contacted at gcousin333@gmail.com.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">-------------------------</span>
<span class="sd">    The parser module</span>
<span class="sd">-------------------------</span>

<span class="sd">Gather facilities for manipulation of handwritten text images:</span>
<span class="sd">extraction of lines, words, characters, etc.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>
<span class="kn">import</span> <span class="nn">string</span> <span class="k">as</span> <span class="nn">stringlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">skimage</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">log_config</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">log_config</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;hwtools.parser&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_front_pixel</span><span class="p">(</span><span class="n">binary_image</span><span class="p">):</span>
    <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">binary_image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">support</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The binary image has no front pixel, returning None.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_sanitized_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
    <span class="c1"># This function is oriented towards &#39;uint*&#39; types.</span>
    <span class="c1"># It should work in many other cases but care should be taken</span>
    <span class="c1"># in case of positively and negatively valued labels arrays,</span>
    <span class="c1"># regarding the type of the returned matrix.</span>
    <span class="n">sanitized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
    <span class="n">vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">new_val</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="n">sanitized</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
        <span class="n">new_val</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">sanitized</span>


<div class="viewcode-block" id="horizontal"><a class="viewcode-back" href="../../index.html#hwtools.parser.horizontal">[docs]</a><span class="k">def</span> <span class="nf">horizontal</span><span class="p">(</span>
    <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">centers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">thickness</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">as_list</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">()</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return horizontal lines with prescribed thickness and centers.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): The image on which the lines should be</span>
<span class="sd">            overlayed.</span>
<span class="sd">        centers (list[int]): the heights at which the lines must appear.</span>
<span class="sd">        thickness (int): the prescribed thickness for the lines.</span>
<span class="sd">        as_list (bool, optional): If the lines are beeing returned in a</span>
<span class="sd">            single image. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray() | list[np.ndarray]: A boolean image that contains</span>
<span class="sd">        all the horizontal lines if as_list==False, else a list of</span>
<span class="sd">        such images, each containing a unique line.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lines_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">centers</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">line</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">lines_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lines_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lines_list</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="bounding_box_slices"><a class="viewcode-back" href="../../index.html#hwtools.parser.bounding_box_slices">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_slices</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the slices that define the bounding box of image.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (np.ndarray): a 2d ndarray</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: &quot;The input image is not 2-d&quot;</span>
<span class="sd">        ValueError: &quot;The given array is null, its bounding</span>
<span class="sd">            box is not well defined.&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[slice,slice]: (s_y,s_x) the pair of slices, s_y for</span>
<span class="sd">            the vertical axes, s_x for the horizontal one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input image is not 2-d&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">image</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The given array is null, its bounding box is not well defined.&quot;</span>
        <span class="p">)</span>
    <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">))</span></div>


<span class="c1"># To optimize: eliminate extraneous version of bounding box, another version is</span>
<span class="c1"># appearing as a method below.</span>
<div class="viewcode-block" id="bounding_box"><a class="viewcode-back" href="../../index.html#hwtools.parser.bounding_box">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the bounding box of a 2d image.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (np.ndarray): A np.ndarray with image.ndim==2.</span>
<span class="sd">            It represents a grayscale or binary image.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The smallest rectangular subimage that contains all</span>
<span class="sd">            non-zero pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sy</span><span class="p">,</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">bounding_box_slices</span><span class="p">(</span><span class="n">image</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">[</span><span class="n">sy</span><span class="p">,</span> <span class="n">sx</span><span class="p">]</span></div>


<span class="c1"># we could try to optimize compsize below stopping once</span>
<span class="c1">#  an expected threshold is reached</span>
<div class="viewcode-block" id="comp_size"><a class="viewcode-back" href="../../index.html#hwtools.parser.comp_size">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">comp_size</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the size of a component in a labeled image.</span>

<span class="sd">    The size is understood as the number of pixels.</span>

<span class="sd">    Args:</span>
<span class="sd">        labels (np.ndarray): an integer valued 2d ndarray</span>
<span class="sd">        val (int): the value whose pixels we want to count.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The number of occurences of value among the pixels of</span>
<span class="sd">            labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">labels</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">))</span></div>


<div class="viewcode-block" id="hand_made_binary_dilation"><a class="viewcode-back" href="../../index.html#hwtools.parser.hand_made_binary_dilation">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hand_made_binary_dilation</span><span class="p">(</span>
    <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">footprint</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Naive binary dilation, cheaper than skimage&#39;s for sparse images.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): The binary image to which the dilation must be</span>
<span class="sd">            applied</span>
<span class="sd">        footprint (np.ndarray): The footprint for the dilation algorithm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: a binary image obtained by binary dilation of img wrt</span>
<span class="sd">            footprint.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">a</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">b</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">support</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># We describe the relevant bounds for the window in img centered</span>
        <span class="c1"># at (y,x).</span>
        <span class="n">top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">u</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="c1"># C = adapted cropped footprint</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">footprint</span><span class="p">[</span>
            <span class="n">u</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">top</span><span class="p">)</span> <span class="p">:</span> <span class="n">u</span> <span class="o">+</span> <span class="n">bottom</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="n">right</span> <span class="o">-</span> <span class="n">x</span>
        <span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span> <span class="o">|</span> <span class="n">C</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="PageExtract"><a class="viewcode-back" href="../../index.html#hwtools.parser.PageExtract">[docs]</a><span class="k">class</span> <span class="nc">PageExtract</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for page extracts, to retain context information.</span>

<span class="sd">    It has strong relations with the class Page.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PageExtract.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.PageExtract.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">char_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">char_thickness</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">char_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">corner_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">corner_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">parent_page_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate self.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (np.ndarray): The image of the page extract</span>
<span class="sd">            char_height (int): An estimate of the characters&#39; height.</span>
<span class="sd">            char_thickness (int): An estimate of the characters&#39;</span>
<span class="sd">                thickness.</span>
<span class="sd">            char_width (int): An estimate of the characters&#39; width.</span>
<span class="sd">            corner_y (int): the top-left corner y coordinate within the</span>
<span class="sd">                parent page.</span>
<span class="sd">            corner_x (int): the top-left corner x coordinate within the</span>
<span class="sd">                parent page.</span>
<span class="sd">            parent_page_shape (tuple[int,int]): The shape of the parent</span>
<span class="sd">            page.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corner_y</span> <span class="o">=</span> <span class="n">corner_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corner_x</span> <span class="o">=</span> <span class="n">corner_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_page_shape</span> <span class="o">=</span> <span class="n">parent_page_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">=</span> <span class="n">char_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span> <span class="o">=</span> <span class="n">char_thickness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span> <span class="o">=</span> <span class="n">char_width</span></div>

<div class="viewcode-block" id="PageExtract.in_page"><a class="viewcode-back" href="../../index.html#hwtools.parser.PageExtract.in_page">[docs]</a>    <span class="k">def</span> <span class="nf">in_page</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put the page extract in its original page.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PageExtract: a page extract of the whole ambient page dimensions,</span>
<span class="sd">            with the input PageExtract at its position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_page_shape</span><span class="p">)</span>
        <span class="n">page</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corner_y</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">corner_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corner_x</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">corner_x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

        <span class="k">return</span> <span class="n">PageExtract</span><span class="p">(</span>
            <span class="n">page</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_page_shape</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PageExtract.__getitem__"><a class="viewcode-back" href="../../index.html#hwtools.parser.PageExtract.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">slice</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PageExtract</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mimick behaviour of __getitem__ for np.ndarray.</span>


<span class="sd">        Args:</span>
<span class="sd">            positions (tuple[slice | int, slice | int]): tuple of</span>
<span class="sd">            indices or slices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PageExtract: The page extract corresponding to the sliced</span>
<span class="sd">                self.image seen within parent_page.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">int2slice</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">slice</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Convert integer index or slice to the corresponding slice.</span>

<span class="sd">            Args:</span>
<span class="sd">                x (int | slice): input integer or slice. Beware that</span>
<span class="sd">                the step in every slice is implicitely considered as 1.</span>

<span class="sd">            Returns:</span>
<span class="sd">                slice: corresponding length 1 slice.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">(</span><span class="n">positions</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">slice</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">positions</span><span class="p">]</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">int2slice</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The given tuple of slices/indices is not valid, returning None.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">corner_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corner_y</span> <span class="o">+</span> <span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">corner_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corner_x</span> <span class="o">+</span> <span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="k">return</span> <span class="n">PageExtract</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span><span class="p">,</span>
            <span class="n">corner_y</span><span class="p">,</span>
            <span class="n">corner_x</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_page_shape</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PageExtract.bounding_box"><a class="viewcode-back" href="../../index.html#hwtools.parser.PageExtract.bounding_box">[docs]</a>    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bounding box of self.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The smallest rectangular subimage that contains</span>
<span class="sd">                all non-zero pixels of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sy</span><span class="p">,</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">bounding_box_slices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">sy</span><span class="p">,</span> <span class="n">sx</span><span class="p">]</span></div>

<div class="viewcode-block" id="PageExtract.changed_image"><a class="viewcode-back" href="../../index.html#hwtools.parser.PageExtract.changed_image">[docs]</a>    <span class="k">def</span> <span class="nf">changed_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PageExtract</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return copy of self with image attribute changed to new_image.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image (np.ndarray): The new image</span>

<span class="sd">        Returns:</span>
<span class="sd">            PageExtract: Copy of self with image attribute changed to</span>
<span class="sd">                new_image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PageExtract</span><span class="p">(</span>
            <span class="n">new_image</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corner_y</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corner_x</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_page_shape</span><span class="p">,</span>
        <span class="p">)</span></div></div>

    <span class="c1"># def union(self, other):</span>
    <span class="c1">#     if self.parent_page_shape != other.parent_page_shape:</span>
    <span class="c1">#         warnings.warn(</span>
    <span class="c1">#             &quot;The two page extracts do not have the same &quot;</span>
    <span class="c1">#             + &quot;parent_page_shape. Make sure these are the right objects.&quot;</span>
    <span class="c1">#         )</span>
    <span class="c1">#     corner_y = min(self.corner_y, other.corner_y)</span>
    <span class="c1">#     corner_x = min(self.corner_x, other.corner_x)</span>


<div class="viewcode-block" id="Line"><a class="viewcode-back" href="../../index.html#hwtools.parser.Line">[docs]</a><span class="k">class</span> <span class="nc">Line</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The class for the lines of the treated scanned  documents.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Line.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.Line.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">page_extract</span><span class="p">:</span> <span class="n">PageExtract</span><span class="p">,</span> <span class="n">line_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate Line objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            page_extract (PageExtract): The underlying PageExtract</span>
<span class="sd">            line_height (int): the line height within</span>
<span class="sd">                page_extract.parent_page.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span> <span class="o">=</span> <span class="n">page_extract</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span> <span class="o">=</span> <span class="n">line_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_words</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self.page_extract.image.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">image</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">complete_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self.page_extract.image != 0.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">image</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basic_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self.page_extract.image == 1.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">satellites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the &#39;satellite&#39; components in self.image.</span>

<span class="sd">        Args:</span>
<span class="sd">            as_list (bool, optional): Whether to return the satellites</span>
<span class="sd">                together as a unique binary image or as a list of</span>
<span class="sd">                distinct connected ones. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            _list[np.ndarray] |np.ndarray: the satellites as a (list of)</span>
<span class="sd">                binary images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">char_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self.page_extract.char_thickness.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">char_thickness</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">char_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self.page_extract.char_height.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">char_height</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">char_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self.page_extract.char_width.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">char_width</span>

<div class="viewcode-block" id="Line.words"><a class="viewcode-back" href="../../index.html#hwtools.parser.Line.words">[docs]</a>    <span class="k">def</span> <span class="nf">words</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_gap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">margin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">line_thickness</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Words</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Words extracted from the line.</span>

<span class="sd">        If a parameter is received as None, it will be given a default</span>
<span class="sd">        integer value, in function of self.</span>
<span class="sd">        Afterwards, the algorithm is as follows: a thickline at</span>
<span class="sd">        line_height is drawn &#39;over&#39; line.image,</span>
<span class="sd">        with thickness determined by line_thickness. Every connected</span>
<span class="sd">        component of line that meets this thick line is considered as</span>
<span class="sd">        participating to the basic_line of the line. (The other</span>
<span class="sd">        components are termed satellites.) Then, if  the connected</span>
<span class="sd">        components are grouped as the equivalence relation obtained by</span>
<span class="sd">        saturation of the relation</span>
<span class="sd">        &#39;the horizontal projections are far from at most max_gap&#39;.</span>

<span class="sd">        Then, the groups with horizontal projection width less than</span>
<span class="sd">        min_width are discarded, considered as noise.</span>

<span class="sd">        For each of the remaining groups, we consider the smallest interval</span>
<span class="sd">        that contains its horizontal projection, enlarge it on both side</span>
<span class="sd">        by margin. The front pixels that lie over these enlarged intervals</span>
<span class="sd">        define the various Words (one per interval).</span>


<span class="sd">        Args:</span>
<span class="sd">            min_width (int | None, optional): _description_. Defaults to None.</span>
<span class="sd">            max_gap (int | None, optional): _description_. Defaults to None.</span>
<span class="sd">            margin (int | None, optional): _description_. Defaults to None.</span>
<span class="sd">            line_thickness (int | None, optional): _description_. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Words]: The calculated Words from self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_words</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">min_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">max_gap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">margin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_words</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_words</span><span class="p">(</span>
                <span class="n">min_width</span><span class="o">=</span><span class="n">min_width</span><span class="p">,</span>
                <span class="n">max_gap</span><span class="o">=</span><span class="n">max_gap</span><span class="p">,</span>
                <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span>
                <span class="n">line_thickness</span><span class="o">=</span><span class="n">line_thickness</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_words</span></div>

    <span class="k">def</span> <span class="nf">_find_words</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">min_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">min_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span>
        <span class="k">if</span> <span class="n">max_gap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_gap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">margin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line_thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span>

        <span class="n">line_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span>
        <span class="n">thickline</span> <span class="o">=</span> <span class="n">horizontal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="p">,</span> <span class="p">[</span><span class="n">line_height</span><span class="p">],</span> <span class="n">line_thickness</span><span class="p">)</span>
        <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">thickline</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_line</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Another options would be</span>
        <span class="c1"># np.unique(np.where(self.basic_line)[1])</span>
        <span class="c1"># but this raises the risk of connection of two words by upper symbols.</span>

        <span class="n">support_bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Support_bounds contains the frontier points of the support,</span>
        <span class="c1"># in increasing order.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                <span class="n">support_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                <span class="n">support_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># We perform some curation of support_bounds,</span>
        <span class="c1"># to ignore small gaps in a word.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">support_bounds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">support_bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">support_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_gap</span><span class="p">:</span>
                <span class="n">support_bounds</span> <span class="o">=</span> <span class="n">support_bounds</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">support_bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1"># Afterwards we perform a similar treatment to avoid empty words,</span>
        <span class="c1"># coming from noise.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">support_bounds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">support_bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">support_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_width</span><span class="p">:</span>
                <span class="n">support_bounds</span> <span class="o">=</span> <span class="n">support_bounds</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">support_bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">Word</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="p">[</span>
                    <span class="p">:,</span>
                    <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">support_bounds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span> <span class="p">:</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="mi">1</span> <span class="o">+</span> <span class="n">support_bounds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">margin</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">support_bounds</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Word"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word">[docs]</a><span class="k">class</span> <span class="nc">Word</span><span class="p">(</span><span class="n">Line</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A subclass of Line that deals with images of handwrittent words.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Word.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">page_extract</span><span class="p">,</span> <span class="n">line_height</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">page_extract</span><span class="p">,</span> <span class="n">line_height</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shapes</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="c1"># We override the words method from superclass Line.</span>
<div class="viewcode-block" id="Word.words"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word.words">[docs]</a>    <span class="k">def</span> <span class="nf">words</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">min_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self and print a warning.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;The &quot;words&quot; method is being called &#39;</span>
            <span class="o">+</span> <span class="s2">&quot;for an instance of the Word subclass.&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; This is not very relevant:&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;in this subclass the method reduces to the identity map.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Word.word_part"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word.word_part">[docs]</a>    <span class="k">def</span> <span class="nf">word_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Word</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of self with  self.image replaced by subimage.</span>

<span class="sd">        Args:</span>
<span class="sd">            sub_image (np.ndarray): the replacement image for self.image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">page_extract</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_extract</span><span class="o">.</span><span class="n">changed_image</span><span class="p">(</span><span class="n">sub_image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Word</span><span class="p">(</span><span class="n">page_extract</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span><span class="p">)</span></div>

<div class="viewcode-block" id="Word.cut"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Word</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of self, but cut, removing the pixels in shapes.</span>

<span class="sd">        Args:</span>
<span class="sd">            shapes (list[np.ndarray]): regions of self.image to turn</span>
<span class="sd">                white. (cutting shapes)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Word: Cut version of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">sub_image</span><span class="p">[</span><span class="n">shape</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_part</span><span class="p">(</span><span class="n">sub_image</span><span class="p">)</span></div>

    <span class="c1"># We use a similar strategy as in find_words to get the components</span>
    <span class="c1"># of the word associated with the connected components of its basic line.</span>
    <span class="c1"># We observe that for every satellite to be attributed to some basic</span>
    <span class="c1"># component, the sat_margin parameter used here should be bigger than</span>
    <span class="c1"># max_gap used in _find_words</span>
<div class="viewcode-block" id="Word.find_word_components"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word.find_word_components">[docs]</a>    <span class="k">def</span> <span class="nf">find_word_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sat_margin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">line_thickness</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># consider_punctuation: bool = False,</span>
        <span class="c1"># punctuation_margin: int | None = None,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Word</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the components of a Word.</span>

<span class="sd">        These components are calculated as the connected components of</span>
<span class="sd">        self.basic_line (as defined for find_words, in terms of</span>
<span class="sd">        line_thickness) plus some satellites of Word, that are considered</span>
<span class="sd">        as belonging to the component if any pixel of them lie over the</span>
<span class="sd">        sat_margin enlarged projection of the component.</span>

<span class="sd">        Args:</span>
<span class="sd">            sat_margin (int | None, optional): The tolerance for</span>
<span class="sd">                satellites attribution. Defaults to None. If None is</span>
<span class="sd">                passed a value is fixed automatically.</span>
<span class="sd">            line_thickness (int | None, optional): The thickness that</span>
<span class="sd">                determines the basic_line computation. Defaults to None.</span>
<span class="sd">                If None is passed a value is fixed automatically.</span>


<span class="sd">        Returns:</span>
<span class="sd">            list[Word]: The list of components of self, as subWords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sat_margin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sat_margin</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># if punctuation_margin is None:</span>
        <span class="c1">#     punctuation_margin = self.char_width // 3</span>
        <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line_thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># TO OPTIMIZE: we are not using the previous labelling of satellites by</span>
        <span class="c1"># the words method of the Line class.</span>
        <span class="n">local_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">complete_line</span>
        <span class="n">line_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span>
        <span class="n">thickline</span> <span class="o">=</span> <span class="n">horizontal</span><span class="p">(</span><span class="n">local_line</span><span class="p">,</span> <span class="p">[</span><span class="n">line_height</span><span class="p">],</span> <span class="n">line_thickness</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">local_line</span><span class="p">)</span>
        <span class="n">basic_comp_projections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">satellites_projections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">i</span>

            <span class="c1"># For satellites attribution,</span>
            <span class="c1"># we will compare vertical projections of a given sat and</span>
            <span class="c1"># the various basic_comps.</span>
            <span class="c1"># We represent the projections of these connected subspaces</span>
            <span class="c1"># as intervals.</span>
            <span class="n">comp_supp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">comp_supp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">comp_supp</span><span class="p">)</span>

            <span class="c1"># Also sort the components in two categories: satellites</span>
            <span class="c1"># and basic line comps.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">comp</span> <span class="o">&amp;</span> <span class="n">thickline</span><span class="p">):</span>
                <span class="n">basic_comp_projections</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">satellites_projections</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>

        <span class="n">complete_components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">basic_comp_projections</span><span class="p">:</span>
            <span class="n">complete_component</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pair</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">sat_margin</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">sat_margin</span>

            <span class="k">for</span> <span class="n">couple</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">satellites_projections</span><span class="p">:</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">couple</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">A</span> <span class="ow">and</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">:</span>
                    <span class="n">complete_component</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">complete_component</span> <span class="o">=</span> <span class="n">_sanitized_labels</span><span class="p">(</span><span class="n">complete_component</span><span class="p">)</span>
            <span class="n">complete_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_part</span><span class="p">(</span><span class="n">complete_component</span><span class="p">))</span>

        <span class="c1"># # This branch is to include punctuation as autonomous word components if necessary.</span>
        <span class="c1"># # They could otherwise appear only as satellites of other components.</span>
        <span class="c1"># if consider_punctuation:</span>
        <span class="c1">#     basic_comp_intervals = [</span>
        <span class="c1">#         projection[0] for projection in basic_comp_projections</span>
        <span class="c1">#     ]</span>
        <span class="c1">#     for couple, j in satellites_projections:</span>
        <span class="c1">#         augmented_list = basic_comp_intervals + [couple]</span>
        <span class="c1">#         augmented_list.sort(key=lambda t: t[0])</span>
        <span class="c1">#         i = augmented_list.index(couple)</span>
        <span class="c1">#         if len(augmented_list) &gt; i + 1:</span>
        <span class="c1">#             top_ok = (</span>
        <span class="c1">#                 augmented_list[i + 1][0] + punctuation_margin</span>
        <span class="c1">#             ) &gt; couple[1]</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             top_ok = True</span>
        <span class="c1">#         if i &gt; 0:</span>
        <span class="c1">#             bottom_ok = (</span>
        <span class="c1">#                 augmented_list[i - 1][1] - punctuation_margin</span>
        <span class="c1">#             ) &lt; couple[0]</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             bottom_ok = True</span>
        <span class="c1">#         if bottom_ok and top_ok:</span>
        <span class="c1">#             # We mark detected punctuation components with the</span>
        <span class="c1">#             # label &#39;2&#39;, to distinguish them from standard complete</span>
        <span class="c1">#             # components that have &#39;1&#39; entries, corresponding to their</span>
        <span class="c1">#             # basic components.</span>
        <span class="c1">#             # Remember that punctuation symbols may contribute several</span>
        <span class="c1">#             # of these punctuation components, because these are</span>
        <span class="c1">#             # connected.</span>
        <span class="c1">#             complete_component = 2 * (labels == j).astype(&quot;uint16&quot;)</span>
        <span class="c1">#             complete_components.append(</span>
        <span class="c1">#                 self.word_part(complete_component)</span>
        <span class="c1">#             )</span>

        <span class="c1"># We will use the next function to sort components from</span>
        <span class="c1"># left to right.</span>
        <span class="k">def</span> <span class="nf">mean_x</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">component</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;mean_x received a component with no positive entry.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>

        <span class="n">complete_components</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">component</span><span class="p">:</span> <span class="n">mean_x</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">complete_line</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">complete_components</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cutting_shape_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prescribe the thickness of cutting shapes for word cutting.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: (3 * self.char_thickness) // 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_is_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_thickness</span>
        <span class="k">if</span> <span class="n">window_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_radius</span> <span class="o">=</span> <span class="n">char_width</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">point</span>
        <span class="n">cut_word</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cut_word</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># The ideal solution would be the one below</span>
        <span class="c1"># return np.amax(skimage.measure.label(cut_word))</span>
        <span class="c1">#        &gt; np.amax(skimage.measure.label(word))</span>
        <span class="c1"># however we take into account computational costs</span>
        <span class="c1"># and consider shortened words.</span>
        <span class="n">shortened_word</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="p">[</span>
            <span class="p">:,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span>
        <span class="p">]</span>
        <span class="n">shortened_cut_word</span> <span class="o">=</span> <span class="n">cut_word</span><span class="p">[</span>
            <span class="p">:,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span>
        <span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">shortened_cut_word</span><span class="p">)</span>
        <span class="n">disconnects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span>
            <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">shortened_word</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">disconnects</span><span class="p">:</span>
            <span class="c1"># We check the local components are either</span>
            <span class="c1"># on the left or on the right of the point</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">window_radius</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">cut_word</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_find_thin_places</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_thickness</span>

        <span class="n">thin_places</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span>

            <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">support_bounds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># support_bounds contains the frontier points of the support,</span>
            <span class="c1"># in increasing order.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                    <span class="n">support_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                    <span class="n">support_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">support_bounds</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">support_bounds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">support_bounds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span>
                    <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="p">):</span>
                    <span class="n">thin_places</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="p">(</span><span class="n">support_bounds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">support_bounds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">])</span>
                            <span class="o">//</span> <span class="mi">2</span>
                            <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">x</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">thin_places</span>

    <span class="c1"># Below, we check at once if a place is of minimal height in the</span>
    <span class="c1"># vertical slice of the word, and if the word is easily cut at this place</span>
    <span class="c1"># (partially checking condition 1 above, and totally checking condition 2)</span>
    <span class="c1"># this is a better version of _find_thin_places</span>
    <span class="k">def</span> <span class="nf">_find_low_and_thin_places</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_thickness</span>

        <span class="n">low_and_thin_places</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span>

            <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">support_bounds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Support_bounds contains the frontier points of the support,</span>
            <span class="c1">#  in increasing order.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                    <span class="n">support_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                    <span class="n">support_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">support_bounds</span>
                <span class="ow">and</span> <span class="n">support_bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">support_bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="p">):</span>
                <span class="n">low_and_thin_places</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">((</span><span class="n">support_bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">support_bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">low_and_thin_places</span>

    <span class="k">def</span> <span class="nf">_is_not_too_excentric</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">line_height</span><span class="p">,</span> <span class="n">tolerated_excentricity</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">tolerated_excentricity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerated_excentricity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">y</span> <span class="o">&gt;</span> <span class="n">line_height</span> <span class="o">-</span> <span class="n">tolerated_excentricity</span>
            <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">line_height</span> <span class="o">+</span> <span class="n">tolerated_excentricity</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_candidates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_thickness</span>
        <span class="k">if</span> <span class="n">window_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">low_and_thin_places</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_low_and_thin_places</span><span class="p">(</span>
            <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span>
        <span class="p">)</span>

        <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">line_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">low_and_thin_places</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_not_too_excentric</span><span class="p">(</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">line_height</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_critical</span><span class="p">(</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span> <span class="n">window_radius</span><span class="o">=</span><span class="n">window_radius</span>
            <span class="p">):</span>
                <span class="n">candidates</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">candidates</span>

    <span class="c1"># To optimize : the candidates above are given as front pixels in an</span>
    <span class="c1"># image and then manipulated in coordinates below, choose one representation</span>
    <span class="c1"># and stick to it: coordinates seem to be a good choice.</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_lowest_points</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">candidates</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">candidates</span><span class="p">[:,</span> <span class="n">x</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
                <span class="n">current_min</span> <span class="o">=</span> <span class="n">y</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In the used coordinates y &gt; current_min  means a lower point.</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">current_min</span><span class="p">:</span>
                    <span class="n">current_min</span> <span class="o">=</span> <span class="n">y</span>
                    <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">current_min</span><span class="p">,</span> <span class="n">x_min</span><span class="p">))</span>
        <span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">points</span>

<div class="viewcode-block" id="Word._touches"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word._touches">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_touches</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">comp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decide if p touches comp on the right, the left or any side.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (tuple[int, int]): A point in an image, coords (y,x)</span>
<span class="sd">            comp (np.ndarray): A set of pixels in this image,</span>
<span class="sd">                given as a boolean array.</span>
<span class="sd">            side (str | None, optional): The side to consider: None,</span>
<span class="sd">                &#39;right&#39; or &#39;left&#39;.</span>
<span class="sd">                Defaults to None. If None is passed, any side is</span>
<span class="sd">                considered valid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if comp is on the side-hand of p,</span>
<span class="sd">                False otherwise. If side is None, True if and only if</span>
<span class="sd">                p touches comp.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">side</span> <span class="o">=</span> <span class="n">side</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">side</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dilated_comp</span> <span class="o">=</span> <span class="n">hand_made_binary_dilation</span><span class="p">(</span>
                <span class="n">comp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
            <span class="n">dilated_comp</span> <span class="o">=</span> <span class="n">hand_made_binary_dilation</span><span class="p">(</span>
                <span class="n">comp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
            <span class="n">dilated_comp</span> <span class="o">=</span> <span class="n">hand_made_binary_dilation</span><span class="p">(</span>
                <span class="n">comp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The side argument was not passed &quot;</span>
                <span class="o">+</span> <span class="s1">&#39;correctly. It must be either &quot;right&quot;, &quot;left&quot; or None.&#39;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dilated_comp</span><span class="p">[</span><span class="n">p</span><span class="p">])</span></div>

<div class="viewcode-block" id="Word._inbetween_piece"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word._inbetween_piece">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_inbetween_piece</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">q</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">cut_comp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">side_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the piece of cut_comp which lies between p and q.</span>


<span class="sd">        Args:</span>
<span class="sd">            p (tuple[int, int]): The left-hand point, in the form (y,x).</span>
<span class="sd">            q (tuple[int, int]): The right-hand point, in the form</span>
<span class="sd">                (y0,x0). We suppose x0&gt;x.</span>
<span class="sd">            cut_comp (np.ndarray): A binary image.</span>
<span class="sd">            side_sensitive (bool): whether one takes into account the</span>
<span class="sd">                side on which p and q are touched by the sought component.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray | None: if side_sensitive is True,</span>
<span class="sd">                 a connected component of cut_comp that</span>
<span class="sd">                touches p on the right-hand side of p and q on the</span>
<span class="sd">                left-hand of q; provided it exists. In this case, it is</span>
<span class="sd">                given as a binary image. If such a component does not</span>
<span class="sd">                exist, None is returned.</span>


<span class="sd">                If side_sensitive is False p or q may touch the</span>
<span class="sd">                sought component on any side. If such a component does</span>
<span class="sd">                not exist, None is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The point p does not lie on the left of q.&quot;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">cut_comp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p_criterion</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">side_sensitive</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">q_criterion</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span> <span class="k">if</span> <span class="n">side_sensitive</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">ok_with_p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Word</span><span class="o">.</span><span class="n">_touches</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_criterion</span><span class="p">):</span>
                <span class="n">ok_with_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok_with_p</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">ok_with_p</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Word</span><span class="o">.</span><span class="n">_touches</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">q_criterion</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">chunk</span></div>

    <span class="k">def</span> <span class="nf">_event_detected</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">q</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">height_tolerance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">pixel_tolerance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">thickness</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;p[1] &gt; q[1]: (p,q)=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;We return the result considering these points as permuted.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">_event_detected</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">p_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shape_from_point</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">thickness</span><span class="p">)</span>
        <span class="n">q_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shape_from_point</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">thickness</span><span class="p">)</span>
        <span class="n">cut_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span>
        <span class="n">cut_comp</span><span class="p">[</span><span class="n">p_shape</span> <span class="o">|</span> <span class="n">q_shape</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="n">Word</span><span class="o">.</span><span class="n">_inbetween_piece</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">cut_comp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">piece</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">max_heights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_heights</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">slice_support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">piece</span><span class="p">[:,</span> <span class="n">x</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">max_heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">slice_support</span><span class="p">))</span>
            <span class="n">min_heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">slice_support</span><span class="p">))</span>
        <span class="n">max_heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">max_heights</span><span class="p">)</span>
        <span class="n">min_heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">min_heights</span><span class="p">)</span>
        <span class="n">pixel_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">piece</span><span class="p">[:,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">max_heights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_heights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">height_tolerance</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">min_heights</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_heights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">height_tolerance</span>
        <span class="p">):</span>
            <span class="c1"># height event</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;height event&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">pixel_number</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pixel_number</span><span class="p">)</span> <span class="o">-</span> <span class="n">pixel_tolerance</span><span class="p">:</span>
            <span class="c1"># pixel event</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pixel_event&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">pixel_number</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pixel_number</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># to optimize: the two methods below were added lately, they could be used</span>
    <span class="c1"># to refactor part of the former code.</span>
    <span class="k">def</span> <span class="nf">_cutting_shape_from_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_thickness</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complete_line</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">shape</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">shape</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cutting_point_from_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">support</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="Word._creates_too_small_comp"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word._creates_too_small_comp">[docs]</a>    <span class="k">def</span> <span class="nf">_creates_too_small_comp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">too_small_comp_radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">min_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if cutting at shape creates too small pieces.</span>

<span class="sd">        Args:</span>
<span class="sd">            shape (np.ndarray): a cutting shape</span>
<span class="sd">            window_radius (int): The radius of the window around shape</span>
<span class="sd">                center in which we perform the size check.</span>
<span class="sd">            min_size (int): the minimal acceptable size for the cut</span>
<span class="sd">                components.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if a too small component would be created,</span>
<span class="sd">                False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Entering _creates_too_small_comp with min_size = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">min_size</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; and too_small_comp_radius = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">too_small_comp_radius</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_point_from_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">too_small_comp_radius</span>
        <span class="n">cut_word</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cut_word</span><span class="p">[</span><span class="n">shape</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">shortened_word</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="p">[:,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">radius</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">shortened_word</span><span class="p">)</span>
        <span class="n">comp_sizes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">small_comps_count</span> <span class="o">=</span> <span class="p">[</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">min_size</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">comp_sizes</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span>
            <span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">shortened_cut_word</span> <span class="o">=</span> <span class="n">cut_word</span><span class="p">[:,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">radius</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">shortened_cut_word</span><span class="p">)</span>
        <span class="n">new_comp_sizes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">new_small_comps_count</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">size</span> <span class="o">&lt;</span> <span class="n">min_size</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">new_comp_sizes</span>
        <span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;small_comps_counts,before cutting: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">small_comps_count</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; after cutting: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_small_comps_count</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;components sizes before cutting: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">comp_sizes</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;components sizes after cutting: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_comp_sizes</span><span class="p">))</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">new_small_comps_count</span> <span class="o">&gt;</span> <span class="n">small_comps_count</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;returning: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">output</span></div>

    <span class="c1"># We define _find_letter_cutting_shapes using this _event_detected</span>
    <span class="c1"># function.</span>
    <span class="c1"># We also take into account the special roles of the beginning and end of</span>
    <span class="c1"># the component.</span>
    <span class="c1"># Warning: in the auxiliary function below,</span>
    <span class="c1"># we are making the assumption that THE BASIC LINE OF SELF IS CONNECTED.</span>

    <span class="k">def</span> <span class="nf">_find_letter_cutting_shapes_in_component</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">height_tolerance</span><span class="p">,</span>
        <span class="n">pixel_tolerance</span><span class="p">,</span>
        <span class="n">window_radius</span><span class="p">,</span>
        <span class="n">thickness</span><span class="p">,</span>
        <span class="n">too_small_comp_radius</span><span class="p">,</span>
        <span class="n">min_size</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">line_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;new_comp&quot;</span><span class="p">)</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_candidates</span><span class="p">(</span>
            <span class="n">thickness</span><span class="p">,</span> <span class="n">window_radius</span><span class="o">=</span><span class="n">window_radius</span>
        <span class="p">)</span>
        <span class="n">lowest_points</span> <span class="o">=</span> <span class="n">Word</span><span class="o">.</span><span class="n">_find_lowest_points</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
        <span class="c1"># We transpose self.basic_line to obtain the (one) leftmost point</span>
        <span class="c1"># for free thanks to the output ordering of np.where.</span>
        <span class="c1"># We also exploit this to get the rightmost point.</span>
        <span class="n">supp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">(</span><span class="n">supp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">supp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># p0 in the form (y,x)</span>
        <span class="n">pinf</span> <span class="o">=</span> <span class="p">(</span><span class="n">supp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">supp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># pinf in the form (y,x)</span>

        <span class="n">projection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basic_line</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span>

        <span class="c1"># We use event_detected to avoid successions of similar cutting shapes.</span>
        <span class="n">filtered_cutting_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comparison_point</span> <span class="o">=</span> <span class="n">p0</span>
        <span class="n">current_pack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">packs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lowest_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_detected</span><span class="p">(</span>
                <span class="n">comparison_point</span><span class="p">,</span>
                <span class="n">p</span><span class="p">,</span>
                <span class="n">height_tolerance</span><span class="o">=</span><span class="n">height_tolerance</span><span class="p">,</span>
                <span class="n">pixel_tolerance</span><span class="o">=</span><span class="n">pixel_tolerance</span><span class="p">,</span>
                <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="n">packs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_pack</span><span class="p">)</span>
                <span class="n">current_pack</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="n">comparison_point</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_pack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">packs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_pack</span><span class="p">)</span>
        <span class="n">filtered_cutting_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pack</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">pack</span> <span class="ow">in</span> <span class="n">packs</span> <span class="k">if</span> <span class="n">pack</span>
        <span class="p">]</span>

        <span class="c1"># We deal here with the special case of useless cutting points close to</span>
        <span class="c1"># the end of the component.</span>
        <span class="k">if</span> <span class="n">filtered_cutting_points</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_detected</span><span class="p">(</span>
            <span class="n">filtered_cutting_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">pinf</span><span class="p">,</span>
            <span class="n">height_tolerance</span><span class="o">=</span><span class="n">height_tolerance</span><span class="p">,</span>
            <span class="n">pixel_tolerance</span><span class="o">=</span><span class="n">pixel_tolerance</span><span class="p">,</span>
            <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">filtered_cutting_points</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">filtered_cutting_points</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shape_from_point</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">thickness</span><span class="p">)</span>
            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># We filter once more using _creates_too_small_comp</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_creates_too_small_comp</span><span class="p">(</span>
                <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">too_small_comp_radius</span><span class="o">=</span><span class="n">too_small_comp_radius</span><span class="p">,</span>
                <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="n">shapes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">filtered_cutting_points</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">filtered_cutting_points</span><span class="p">)</span>

    <span class="c1"># Now we use this to propose the cutting shapes for a whole line or word,</span>
    <span class="c1"># thus possibly disconnected.</span>
    <span class="k">def</span> <span class="nf">_find_letter_cutting_shapes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">height_tolerance</span><span class="p">,</span>
        <span class="n">pixel_tolerance</span><span class="p">,</span>
        <span class="n">window_radius</span><span class="p">,</span>
        <span class="n">thickness</span><span class="p">,</span>
        <span class="n">too_small_comp_radius</span><span class="p">,</span>
        <span class="n">min_size</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">line_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_word_components</span><span class="p">()</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">temp_shapes</span><span class="p">,</span>
                <span class="n">temp_points</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">_find_letter_cutting_shapes_in_component</span><span class="p">(</span>
                <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span>
                <span class="n">height_tolerance</span><span class="o">=</span><span class="n">height_tolerance</span><span class="p">,</span>
                <span class="n">pixel_tolerance</span><span class="o">=</span><span class="n">pixel_tolerance</span><span class="p">,</span>
                <span class="n">window_radius</span><span class="o">=</span><span class="n">window_radius</span><span class="p">,</span>
                <span class="n">too_small_comp_radius</span><span class="o">=</span><span class="n">too_small_comp_radius</span><span class="p">,</span>
                <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">shapes</span> <span class="o">+=</span> <span class="n">temp_shapes</span>
            <span class="n">points</span> <span class="o">+=</span> <span class="n">temp_points</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)))</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="n">points</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>

<div class="viewcode-block" id="Word.cutting_shapes"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word.cutting_shapes">[docs]</a>    <span class="k">def</span> <span class="nf">cutting_shapes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">height_tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pixel_tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">window_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">thickness</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">too_small_comp_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">recompute</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find where to cut self to separate its letters.</span>

<span class="sd">        We explain below the aspects of the algorithm that are tunable</span>
<span class="sd">        through the function parameters. For this discussion, we suppose</span>
<span class="sd">        None of the parameter is passed as None.</span>

<span class="sd">        A cut/cutting shape is a 1 pixel width rectangular region in</span>
<span class="sd">        self.image. The parameter of the algorithm that fixes the height</span>
<span class="sd">        of the sought cutting shapes is &#39;thickness&#39;. A cutting shape</span>
<span class="sd">        should enjoy the property that once it is removed from</span>
<span class="sd">        self.basic_component, the latter&#39;s number of connected components</span>
<span class="sd">        augments.</span>

<span class="sd">        We actually check a slightly different property: the shape must</span>
<span class="sd">        disconnect the restriction of self.basic_line to a square window</span>
<span class="sd">        of radius &#39;window_radius&#39;, we also</span>
<span class="sd">        require that no pixel of self.basic_line remains in that window</span>
<span class="sd">        on the vertical line that contains the cut.</span>

<span class="sd">        For each component of self, as calculated as self.find_components(),</span>
<span class="sd">        the algorithm determines a first set of cut candidates that</span>
<span class="sd">        respects the conditions above (among others).</span>
<span class="sd">        The candidates are ordered from left to right. We add</span>
<span class="sd">        Still componentwise, the leftmost and rightmost pixel of</span>
<span class="sd">        self.basic_line to the list.</span>
<span class="sd">        This list is filtered from left to right, to ensure some kind of</span>
<span class="sd">        event happens between two succesive points: either height events</span>
<span class="sd">        or pixel events.</span>

<span class="sd">         - We consider some height event happens between two</span>
<span class="sd">                elements of the list if the part of self.basic_component that links</span>
<span class="sd">                them has at least a height variation of &#39;height_tolerance&#39;.</span>
<span class="sd">         - We consider some pixel  event happens between two</span>
<span class="sd">                elements of the list if the part of self.basic_component that links</span>
<span class="sd">                them has at least a variation of &#39;pixel_tolerance&#39; for the number</span>
<span class="sd">                of pixel in its 1-pixel wide vertical slices.</span>

<span class="sd">        Any element of the list is eliminated if no such event happens</span>
<span class="sd">        between it and the preceding element (of the updated list).</span>

<span class="sd">        [...]</span>

<span class="sd">        Finally, We want to remove the cuts that would create too small</span>
<span class="sd">        pieces. This is tested in restriction to a square window of radius</span>
<span class="sd">        &#39;too_small_comp_radius&#39;, the newly created components in that</span>
<span class="sd">        window must be bigger or equal than &#39;min_size&#39; for the cut to be</span>
<span class="sd">        acceptable.</span>


<span class="sd">        Args:</span>
<span class="sd">            height_tolerance (int | None, optional): Tolerance for</span>
<span class="sd">                height events. Defaults to None. If None is passed a value</span>
<span class="sd">                is fixed automatically.</span>
<span class="sd">            pixel_tolerance (int | None, optional): Tolerance for</span>
<span class="sd">                pixel events. Defaults to None. If None is passed a value</span>
<span class="sd">                is fixed automatically.</span>
<span class="sd">            window_radius (int | None, optional): Window size for</span>
<span class="sd">                disconnection test. Defaults to None.If None is passed, a</span>
<span class="sd">                value is fixed automatically.</span>
<span class="sd">            thickness (int | None, optional): The thickness for the</span>
<span class="sd">                cutting shapes. Defaults to None. If None is passed a</span>
<span class="sd">                value is fixed automatically.</span>
<span class="sd">            too_small_comp_radius (int | None, optional): Window size for</span>
<span class="sd">                new component size test. Defaults to None. If None is</span>
<span class="sd">                passed a value is fixed automatically.</span>
<span class="sd">            min_size (int | None, optional): The minimal acceptable size</span>
<span class="sd">                in new component size test. Defaults to None. If None is</span>
<span class="sd">                passed a value is fixed automatically.</span>
<span class="sd">            recompute (int | None, optional): If the cuts should be</span>
<span class="sd">                recomputed. Defaults to False. To spare computation,</span>
<span class="sd">                it is prefered to store the output after the first call</span>
<span class="sd">                of this method. When testing new parameter values, use</span>
<span class="sd">                recompute=True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[list[np.ndarray],tuple[int,int]]: The list of cutting</span>
<span class="sd">            shapes as binary images of the same shape as self.image and</span>
<span class="sd">            the list of the centers of these shapes in the coordinates</span>
<span class="sd">            of self.image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">height_tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height_tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="n">pixel_tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pixel_tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span>
        <span class="k">if</span> <span class="n">window_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">6</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_thickness</span>
        <span class="k">if</span> <span class="n">too_small_comp_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">too_small_comp_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span>
        <span class="k">if</span> <span class="n">min_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">too_small_comp_radius</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shapes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">recompute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_letter_cutting_shapes</span><span class="p">(</span>
                <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span>
                <span class="n">height_tolerance</span><span class="o">=</span><span class="n">height_tolerance</span><span class="p">,</span>
                <span class="n">pixel_tolerance</span><span class="o">=</span><span class="n">pixel_tolerance</span><span class="p">,</span>
                <span class="n">window_radius</span><span class="o">=</span><span class="n">window_radius</span><span class="p">,</span>
                <span class="n">too_small_comp_radius</span><span class="o">=</span><span class="n">too_small_comp_radius</span><span class="p">,</span>
                <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutting_shapes</span></div>

    <span class="c1"># To DEBUG:</span>
    <span class="c1"># The following method needs enhancement, see ValueError call.</span>
<div class="viewcode-block" id="Word._normalized_image"><a class="viewcode-back" href="../../index.html#hwtools.parser.Word._normalized_image">[docs]</a>    <span class="k">def</span> <span class="nf">_normalized_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">char_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">char_thickness</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize word.</span>


<span class="sd">        Normalize word to a given char_height and char_thickness</span>
<span class="sd">        and arrange for line_height to be half of the new</span>
<span class="sd">        self.image.shape[0].</span>

<span class="sd">        Args:</span>
<span class="sd">            char_height (int): the sought char_height</span>
<span class="sd">            char_thickness (int): the sought char_thickness</span>

<span class="sd">        Returns:</span>
<span class="sd">            Word: the normalized Word</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">char_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">char_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span>
        <span class="k">if</span> <span class="n">char_thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">char_thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">char_height</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span>
            <span class="ow">and</span> <span class="n">char_thickness</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The normalized_image method does not deal with &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;char_height or char_thickness changes for the moment!&quot;</span>
            <span class="p">)</span>

        <span class="n">sy</span><span class="p">,</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">bounding_box_slices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">ymax</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">start</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_height</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">u0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">-</span><span class="n">u0</span><span class="p">,</span> <span class="n">sx</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">sx</span><span class="o">.</span><span class="n">start</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:</span><span class="n">u1</span><span class="p">,</span> <span class="n">sx</span><span class="p">],</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">u1</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">:</span>
            <span class="n">new_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">u0</span><span class="p">:,</span> <span class="n">sx</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">u1</span> <span class="o">-</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">sx</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">sx</span><span class="o">.</span><span class="n">start</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">u0</span><span class="p">:</span><span class="n">u1</span><span class="p">,</span> <span class="n">sx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">new_image</span></div></div>


<div class="viewcode-block" id="Page"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page">[docs]</a><span class="k">class</span> <span class="nc">Page</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The class for the pages of the treated scanned  documents.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Page._black_pixels_to_front"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page._black_pixels_to_front">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_black_pixels_to_front</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts image to a boolean array where black pixels become True.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (np.ndarray): The image to treat.</span>

<span class="sd">        Returns :</span>
<span class="sd">            A np.ndarray of &#39;bool&#39; type where the black pixels of img are</span>
<span class="sd">            converted to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">the_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">the_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">median</span> <span class="o">&gt;</span> <span class="n">the_max</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&lt;</span> <span class="n">the_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">the_max</span> <span class="o">-</span> <span class="n">the_min</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;</span> <span class="n">the_max</span> <span class="o">-</span> <span class="p">(</span><span class="n">the_max</span> <span class="o">-</span> <span class="n">the_min</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A 2-dimensional np.ndarray was expected.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Page.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">char_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">char_thickness</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">char_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate Page Object.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (np.ndarray): The image of a scanned handwritten text.</span>
<span class="sd">            char_height (int): An estimate of the height of the character,</span>
<span class="sd">                measured in pixels.</span>
<span class="sd">                The value should be around the height of an upper case</span>
<span class="sd">                character.</span>
<span class="sd">            char_thickness (int): The thickness of the characters, in</span>
<span class="sd">                pixels.</span>
<span class="sd">            char_width (int): The approximate width of a lower case</span>
<span class="sd">                character, in pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">Page</span><span class="o">.</span><span class="n">_black_pixels_to_front</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_heights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lines</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">=</span> <span class="n">char_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span> <span class="o">=</span> <span class="n">char_thickness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span> <span class="o">=</span> <span class="n">char_width</span></div>

<div class="viewcode-block" id="Page.extract"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PageExtract</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Give the PageExtract of self associated to sub_image.</span>

<span class="sd">        Args:</span>
<span class="sd">            sub_image (ndarray): an ndarray with the same shape as self.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PageExtract: The bounding box of the front (non zero )</span>
<span class="sd">            pixels of sub_image as a PageExtract.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">bounding_box_slices</span><span class="p">(</span><span class="n">sub_image</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sy</span><span class="p">,</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">PageExtract</span><span class="p">(</span>
            <span class="n">sub_image</span><span class="p">[</span><span class="n">sy</span><span class="p">,</span> <span class="n">sx</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_width</span><span class="p">,</span>
            <span class="n">sy</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">sx</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Page.extract_line"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.extract_line">[docs]</a>    <span class="k">def</span> <span class="nf">extract_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">line_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Line</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert subimage and line height to a line.</span>

<span class="sd">        Args:</span>
<span class="sd">            sub_image (ndarray): Has the same shape as self and has</span>
<span class="sd">            front pixels corresponding to a given line.</span>
<span class="sd">            line_height (int): A y coordinate in self for the</span>
<span class="sd">            line&#39;s height.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Line: The he resulting line in the bounding</span>
<span class="sd">            box of sub_image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">page_extract</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">sub_image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Line</span><span class="p">(</span><span class="n">page_extract</span><span class="p">,</span> <span class="n">line_height</span> <span class="o">-</span> <span class="n">page_extract</span><span class="o">.</span><span class="n">corner_y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Page.line_heights"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.line_heights">[docs]</a>    <span class="k">def</span> <span class="nf">line_heights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">smoothing_window_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">noise_removal</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the line heights are already computed.</span>
<span class="sd">        If yes, these are returned. Else they are computed.</span>
<span class="sd">        If one of the optional parameter values is specified,</span>
<span class="sd">        the line heights are recomputed with the prescribed parameter</span>
<span class="sd">        values.</span>

<span class="sd">        The algorithm is based on finding the local maxima of the function</span>
<span class="sd">        height-&gt;pixel count of the 1-pixel-high vertical line with this</span>
<span class="sd">        height. However, before analyzing the function, it is smoothened</span>
<span class="sd">        by replacing the function&#39;s values by homogeneous means over</span>
<span class="sd">        intervals of width &#39;smoothing_window_width&#39;.</span>

<span class="sd">        Some local maxima are considerd irrelevant and discarded</span>
<span class="sd">        if the value fo the smoothened function is not over</span>
<span class="sd">        &#39;noise_removal&#39; at these local maxima.</span>

<span class="sd">        Actually, The notion of a local maximum may be discretized in</span>
<span class="sd">        various manners. Ours is the following, defined in terms of the</span>
<span class="sd">        parameter &#39;delta&#39;: a point p is considered</span>
<span class="sd">        a local maximum if the values at p+delta and p-delta are smaller</span>
<span class="sd">        or equal than the value at p.</span>

<span class="sd">        Args:</span>
<span class="sd">            delta (int | None, optional): Defines the used notion of local</span>
<span class="sd">                maximum. Defaults to None. If None is passed, a value</span>
<span class="sd">                is fixed automatically.</span>
<span class="sd">            smoothing_window_width (int | None, optional): Defines the</span>
<span class="sd">                sized of the used smoothing window. Defaults to None.</span>
<span class="sd">                If None is passed, a value is fixed automatically.</span>
<span class="sd">            noise_removal (int | None, optional): Define the pixel number</span>
<span class="sd">                threshold under which the line is ignored. Defaults to</span>
<span class="sd">                None. If None is passed, n value is fixed automatically.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The relevant line heights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_heights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">smoothing_window_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">noise_removal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">heights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_line_heights</span><span class="p">(</span>
                <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span>
                <span class="n">smoothing_window_width</span><span class="o">=</span><span class="n">smoothing_window_width</span><span class="p">,</span>
                <span class="n">noise_removal</span><span class="o">=</span><span class="n">noise_removal</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_line_heights</span> <span class="o">=</span> <span class="n">heights</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_heights</span></div>

<div class="viewcode-block" id="Page._find_line_heights"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page._find_line_heights">[docs]</a>    <span class="k">def</span> <span class="nf">_find_line_heights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smoothing_window_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noise_removal</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the line heights in terms of certain</span>
<span class="sd">        options, see line_heights docstring.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">smoothing_window_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">smoothing_window_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span>
        <span class="k">if</span> <span class="n">noise_removal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise_removal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span> <span class="o">//</span> <span class="mi">3</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
        <span class="n">v_rep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">v_rep_smooth</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">v_rep</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">smoothing_window_width</span><span class="p">))</span>
        <span class="n">line_heights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interval_first_point</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interval_width</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># we obtain intervals of contiguous local max, we record these</span>
        <span class="c1"># intervals and take their centers</span>
        <span class="n">on_top</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_rep</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">v_rep</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">delta</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delta</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">delta</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_rep</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_rep</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="ow">and</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delta</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">on_top</span><span class="p">:</span>
                    <span class="n">interval_width</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">interval_first_point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">interval_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">on_top</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">on_top</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">line_heights</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">interval_first_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">interval_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">interval_width</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">filtered_line_heights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">line_heights</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v_rep_smooth</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">noise_removal</span><span class="p">:</span>
                <span class="n">filtered_line_heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_line_heights</span></div>

<div class="viewcode-block" id="Page.lines_number"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.lines_number">[docs]</a>    <span class="k">def</span> <span class="nf">lines_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of detected lines in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_heights</span><span class="p">())</span></div>

<div class="viewcode-block" id="Page.what_line_heights"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.what_line_heights">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">what_line_heights</span><span class="p">(</span>
        <span class="n">subimage</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndimage</span><span class="p">,</span> <span class="n">line_heights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">line_thickness</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the line heights relevant to a subimage of a Page.</span>

<span class="sd">            Returns the elements h of line_heights such that a thickline</span>
<span class="sd">            of thickness line_thickness centered at height h meets some</span>
<span class="sd">            non  0 pixel of subimage.</span>

<span class="sd">        Args:</span>
<span class="sd">            subimage (np.ndimage): The subimage (a grayscale or booelan</span>
<span class="sd">                image)</span>
<span class="sd">            line_heights (list[int]): The line heights to be tested</span>
<span class="sd">            line_thickness (int): The thickness parameter of the test.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: List of heights that pass the test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">thick_lines</span> <span class="o">=</span> <span class="n">horizontal</span><span class="p">(</span>
            <span class="n">subimage</span><span class="p">,</span> <span class="n">line_heights</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">line_heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line_heights</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">thick_lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">subimage</span><span class="p">)</span>
        <span class="p">]</span></div>

    <span class="c1"># we will need to separate lines related by an accidental symbol going from one line to another</span>
    <span class="k">def</span> <span class="nf">_find_bridges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">bridged_lines</span><span class="p">,</span> <span class="n">line_heights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">line_heights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line_heights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_heights</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line_thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">bridged_lines_heights</span> <span class="o">=</span> <span class="n">Page</span><span class="o">.</span><span class="n">what_line_heights</span><span class="p">(</span>
            <span class="n">bridged_lines</span><span class="p">,</span> <span class="n">line_heights</span><span class="p">,</span> <span class="n">line_thickness</span>
        <span class="p">)</span>
        <span class="n">bridges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bridged_lines_heights</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">h1</span> <span class="o">=</span> <span class="n">bridged_lines_heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">h2</span> <span class="o">=</span> <span class="n">bridged_lines_heights</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">cut1</span> <span class="o">=</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">line_thickness</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">cut2</span> <span class="o">=</span> <span class="n">h2</span> <span class="o">-</span> <span class="n">line_thickness</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">white_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bridged_lines</span><span class="p">[:</span><span class="n">cut1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">white_bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bridged_lines</span><span class="p">[</span><span class="n">cut2</span><span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>

            <span class="n">in_between</span> <span class="o">=</span> <span class="n">bridged_lines</span><span class="p">[</span><span class="n">cut1</span><span class="p">:</span><span class="n">cut2</span><span class="p">]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">in_between</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">v_rep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">v_rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_rep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bridges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">white_top</span><span class="p">,</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">,</span> <span class="n">white_bottom</span><span class="p">])</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">bridges</span>
        <span class="c1"># we observe that bridged_lines need not be necessarily bridged,</span>
        <span class="c1">#  the returned list can as well be empty.</span>

    <span class="k">def</span> <span class="nf">_bridge_cutting_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bridge</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="n">v_rep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v_rep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">region</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">bottom</span> <span class="o">+</span> <span class="n">top</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">thin</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_rep</span> <span class="o">&lt;</span> <span class="n">thickness</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">v_rep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># we find the right place to cut by successive approximations</span>
        <span class="n">right_place</span> <span class="o">=</span> <span class="n">center</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">thin</span><span class="p">):</span>
            <span class="n">min_thickness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">v_rep</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bottom</span><span class="p">])</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v_rep</span> <span class="o">==</span> <span class="n">min_thickness</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">right_place</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">right_place</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">right_place</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">right_place_line</span> <span class="o">=</span> <span class="n">horizontal</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="p">[</span><span class="n">right_place</span><span class="p">],</span> <span class="n">thickness</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">right_place_line</span> <span class="o">&amp;</span> <span class="n">bridge</span>

        <span class="k">return</span> <span class="n">shape</span>

<div class="viewcode-block" id="Page.lines"><a class="viewcode-back" href="../../index.html#hwtools.parser.Page.lines">[docs]</a>    <span class="k">def</span> <span class="nf">lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Lines</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Separate the Lines of self.</span>

<span class="sd">        The used algorithm separates the lines in the following manners.</span>
<span class="sd">        For each height in self.line_heights(), imagine a thick horizontal</span>
<span class="sd">        line centerd at this height, whith thickness given by the</span>
<span class="sd">        &#39;line_thickness&#39; parameter.</span>

<span class="sd">        If no connected component of</span>
<span class="sd">        self.image meets two of these thick lines, one wishes to put</span>
<span class="sd">        together all the components that touch a given thickline to form</span>
<span class="sd">        the basic line attributed to the corresponding height. Afterwards,</span>
<span class="sd">        the still non attributed components are considered as satellites</span>
<span class="sd">        and attached to some basic lines under certain criteria.</span>

<span class="sd">        When some connected component of self.image meets several of</span>
<span class="sd">        these thick lines, a cutting procedure is used to separate the</span>
<span class="sd">        various batches.</span>


<span class="sd">        Args:</span>
<span class="sd">            line_thickness (int| None, optional): The thickness parameter</span>
<span class="sd">                of the algorithm. Defaults to None. If None is passed,</span>
<span class="sd">                this parameter is set automatically.</span>


<span class="sd">        Returns:</span>
<span class="sd">            list[Lines]: The list of the constructed Lines, one per element</span>
<span class="sd">                in self.line_height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basic_lines</span><span class="p">,</span> <span class="n">satellites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_basic_lines</span><span class="p">(</span>
                <span class="n">line_thickness</span><span class="o">=</span><span class="n">line_thickness</span>
            <span class="p">)</span>

            <span class="n">complete_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_constellations</span><span class="p">(</span>
                <span class="n">basic_lines</span><span class="p">,</span>
                <span class="n">satellites</span><span class="p">,</span>
                <span class="n">line_thickness</span><span class="o">=</span><span class="n">line_thickness</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lines</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extract_line</span><span class="p">(</span><span class="n">complete_lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_heights</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">complete_lines</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lines</span></div>

    <span class="k">def</span> <span class="nf">_find_basic_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line_thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
        <span class="n">line_heights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_heights</span><span class="p">()</span>
        <span class="n">h_lines</span> <span class="o">=</span> <span class="n">horizontal</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">line_heights</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">)</span>

        <span class="c1"># components labeling</span>
        <span class="n">to_be_labeled</span> <span class="o">=</span> <span class="n">h_lines</span> <span class="o">|</span> <span class="n">img</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">to_be_labeled</span><span class="p">)</span>

        <span class="c1"># components classification, by size</span>
        <span class="n">big_enough</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fat_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">comp_size</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_thickness</span><span class="o">**</span><span class="mi">2</span> <span class="o">//</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">big_enough</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">fat_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># print(&quot;total number of components:&quot;, len(big_enough) + len(fat_lines))</span>
        <span class="c1"># big_enough = [</span>
        <span class="c1">#    i</span>
        <span class="c1">#    for i in range(1, np.amax(labels) + 1)</span>
        <span class="c1">#    if check_comp_size(</span>
        <span class="c1">#        labels, i, threshold=self.char_thickness**2 // 4</span>
        <span class="c1">#    )</span>
        <span class="c1"># ]</span>
        <span class="c1"># fat_lines = [</span>
        <span class="c1">#    i</span>
        <span class="c1">#    for i in big_enough</span>
        <span class="c1">#    if check_comp_size(</span>
        <span class="c1">#        labels, i, threshold=self.char_height // 8 * img.shape[1]</span>
        <span class="c1">#    )</span>
        <span class="c1"># ]</span>

        <span class="n">tentative_lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">((</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fat_lines</span>
        <span class="p">]</span>
        <span class="n">satellites</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">((</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">big_enough</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fat_lines</span>
        <span class="p">]</span>

        <span class="n">the_satellites</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">satellites</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># we find bridges in the_tentative_lines and cut them.</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t_line</span> <span class="ow">in</span> <span class="n">tentative_lines</span><span class="p">:</span>
            <span class="n">bridges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bridges</span><span class="p">(</span><span class="n">t_line</span><span class="p">,</span> <span class="n">line_thickness</span><span class="o">=</span><span class="n">line_thickness</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bridge</span> <span class="ow">in</span> <span class="n">bridges</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bridge_cutting_shape</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span>
                <span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span> <span class="o">|</span> <span class="n">shape</span>

        <span class="n">the_tentative_lines</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tentative_lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">the_basic_lines</span> <span class="o">=</span> <span class="n">the_tentative_lines</span> <span class="o">^</span> <span class="n">shapes</span>

        <span class="c1"># we then use the same labeling strategy with the_basic_lines</span>
        <span class="n">to_be_labeled</span> <span class="o">=</span> <span class="n">h_lines</span> <span class="o">|</span> <span class="n">the_basic_lines</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">to_be_labeled</span><span class="p">)</span>
        <span class="n">basic_lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">img</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># The basic lines seem to be ordered with respect to their line</span>
        <span class="c1"># heights but this feature is not clearly guaranteed</span>
        <span class="c1"># by skimage.measure.label</span>
        <span class="n">basic_lines</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="n">Page</span><span class="o">.</span><span class="n">what_line_heights</span><span class="p">(</span>
                <span class="n">line</span><span class="p">,</span> <span class="n">line_heights</span><span class="p">,</span> <span class="n">line_thickness</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">basic_lines</span><span class="p">,</span> <span class="n">the_satellites</span><span class="p">]</span>

    <span class="c1"># we try to attribute the satellites to the right lines</span>

    <span class="k">def</span> <span class="nf">_line_constellations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">basic_lines</span><span class="p">,</span>
        <span class="n">the_satellites</span><span class="p">,</span>
        <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fatness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line_thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">fatness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fatness</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_height</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="n">thick_lines</span> <span class="o">=</span> <span class="n">horizontal</span><span class="p">(</span>
            <span class="n">the_satellites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_heights</span><span class="p">(),</span> <span class="n">line_thickness</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">used_sats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
        <span class="n">complete_lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">fatness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">fatness</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">[[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">fatness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">fatness</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">fatness</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">fatness</span> <span class="o">-</span> <span class="n">fatness</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basic_lines</span><span class="p">)):</span>
            <span class="n">basic_line</span> <span class="o">=</span> <span class="n">basic_lines</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">thick_line</span> <span class="o">=</span> <span class="n">thick_lines</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">basic_line</span> <span class="o">|</span> <span class="n">the_satellites</span>
            <span class="c1"># Tried to enhance perf using grey dilation instead of binary dilation</span>
            <span class="c1"># it was actually worst.</span>
            <span class="c1"># The hand_made_binary_dilation used below has actually</span>
            <span class="c1"># better performance than the one of skimage, provided the binary</span>
            <span class="c1"># image is sparse enough, namely has less than 2% of front pixels.</span>
            <span class="n">fattened_line</span> <span class="o">=</span> <span class="n">hand_made_binary_dilation</span><span class="p">(</span>
                <span class="p">(</span><span class="n">basic_line</span> <span class="o">|</span> <span class="n">thick_line</span><span class="p">),</span> <span class="n">footprint</span>
            <span class="p">)</span>
            <span class="n">to_be_labeled</span> <span class="o">=</span> <span class="n">fattened_line</span> <span class="o">|</span> <span class="n">the_satellites</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">to_be_labeled</span><span class="p">)</span>
            <span class="c1"># We keep track of the various satellites labelling in complete_line.</span>
            <span class="c1"># The basic_line is labelled with 1.</span>
            <span class="n">the_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fattened_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">labels</span><span class="p">)</span>
            <span class="n">complete_line</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">((</span><span class="n">labels</span> <span class="o">==</span> <span class="n">the_label</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">the_label</span>
                    <span class="k">for</span> <span class="n">the_label</span> <span class="ow">in</span> <span class="n">the_labels</span>
                    <span class="k">if</span> <span class="n">the_label</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">_front_pixel</span><span class="p">(</span><span class="n">basic_line</span><span class="p">)</span>
            <span class="n">basic_line_label</span> <span class="o">=</span> <span class="n">complete_line</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">complete_line</span><span class="p">[</span><span class="n">complete_line</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_line_label</span>
            <span class="n">complete_line</span><span class="p">[</span><span class="n">basic_line</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">complete_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">complete_line</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">complete_lines</span></div>


<div class="viewcode-block" id="MatchedGlyph"><a class="viewcode-back" href="../../index.html#hwtools.parser.MatchedGlyph">[docs]</a><span class="k">class</span> <span class="nc">MatchedGlyph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The class of matched glyphs i.e.  pairs (glyph,string).</span>

<span class="sd">    Here we mainly consider glyphs as Words formed by a single handwritten</span>
<span class="sd">    character. However, if needed we might accept also the generalized concept</span>
<span class="sd">    of the iamge representation of a piece of text that can be extracted</span>
<span class="sd">    from a page as a Word object.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MatchedGlyph.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.MatchedGlyph.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">glyph</span><span class="p">:</span> <span class="n">Word</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate MatchedGlyph, matching pairs (glyph,string).</span>

<span class="sd">        Args:</span>
<span class="sd">            glyph (Word): a Word object formed around the image representation</span>
<span class="sd">                of a string</span>
<span class="sd">            string (str): The string represented in the Word.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glyph</span> <span class="o">=</span> <span class="n">glyph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">string</span></div></div>


<div class="viewcode-block" id="WordMatcher"><a class="viewcode-back" href="../../index.html#hwtools.parser.WordMatcher">[docs]</a><span class="k">class</span> <span class="nc">WordMatcher</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to match glyphs with strings.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="WordMatcher.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.WordMatcher.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="n">Word</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">punctuation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the glyph matcher.</span>

<span class="sd">        Args:</span>
<span class="sd">            word (Word): a suitably cut Word,</span>
<span class="sd">                that may include punctuation.</span>
<span class="sd">            text (str): the text to be matched with the Word</span>
<span class="sd">                punctuation (str, optional): The set of characters to be</span>
<span class="sd">                considered as punctuation. If not passed, it will be deduced</span>
<span class="sd">                from the punctuation variable of the string package.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">word</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">punctuation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">=</span> <span class="n">punctuation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\u2014</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">stringlib</span><span class="o">.</span><span class="n">punctuation</span></div>

    <span class="c1"># We once imagined to give a special role to punctuation/any family of</span>
    <span class="c1"># distinguished characters when matching,</span>
    <span class="c1"># whence the writing of the methods punctuation_split and has_punctuation.</span>
    <span class="c1"># We do not use this strategy for the moment.</span>

<div class="viewcode-block" id="WordMatcher.punctuation_split"><a class="viewcode-back" href="../../index.html#hwtools.parser.WordMatcher.punctuation_split">[docs]</a>    <span class="k">def</span> <span class="nf">punctuation_split</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Separate self.text in word blocks and punctuation blocks.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: the list of its blocks, by order of appearance.</span>
<span class="sd">                The list always starts with a non punctuation block,</span>
<span class="sd">                possibly empty, so that odd index blocks correspond</span>
<span class="sd">                exactly to punctuation blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_punctuation_block</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">current_block</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
            <span class="n">is_changing</span> <span class="o">=</span> <span class="p">(</span><span class="n">char</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">punctuation</span><span class="p">)</span> <span class="o">!=</span> <span class="n">is_punctuation_block</span>
            <span class="k">if</span> <span class="n">is_changing</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_block</span><span class="p">)</span>
                <span class="n">is_punctuation_block</span> <span class="o">^=</span> <span class="kc">True</span>
                <span class="n">current_block</span> <span class="o">=</span> <span class="n">char</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_block</span> <span class="o">+=</span> <span class="n">char</span>
        <span class="k">if</span> <span class="n">current_block</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_block</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_punctuation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decide if self.text contains punctuation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if self.text contains punctuation, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">punctuation</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="WordMatcher.match"><a class="viewcode-back" href="../../index.html#hwtools.parser.WordMatcher.match">[docs]</a>    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">MatchedGlyph</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to match self.Word with self.text as MatchedGlyphs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: &quot;The number of components in self.Word do not</span>
<span class="sd">                match self.text&#39;s length.&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[MatchedGlyph]: The deduced list of MatchedGlyphs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="o">.</span><span class="n">find_word_components</span><span class="p">(</span><span class="n">sat_margin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of components in self.Word do not &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;match self.text&#39;s length.&quot;</span>
            <span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MatchedGlyph</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="CutInfo"><a class="viewcode-back" href="../../index.html#hwtools.parser.CutInfo">[docs]</a><span class="k">class</span> <span class="nc">CutInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The class for information on tentative cuts, good or wrong ones.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CutInfo.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.CutInfo.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subword</span><span class="p">:</span> <span class="n">Word</span><span class="p">,</span>
        <span class="n">cutting_shape_chars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">quality</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate CutInfo</span>

<span class="sd">        Args:</span>
<span class="sd">            subword (Word): the surrounding Word of a tentative cut,</span>
<span class="sd">                extracted between the two neighboring tentative cuts.</span>
<span class="sd">                (The end and beginning of the parsed Word are considered</span>
<span class="sd">                neighboring tentative cuts in the definition of the</span>
<span class="sd">                surrounding Word)</span>
<span class="sd">            cutting_shape_chars (tuple[int,int,int]): The cutting shape</span>
<span class="sd">                described as a tuple (y,x,height) where (y,x) are the</span>
<span class="sd">                coordinates of the center of the cutting vertical segment</span>
<span class="sd">                and height is its height.</span>
<span class="sd">            quality (bool): True if the user accepted the cut, False</span>
<span class="sd">                otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">cutting_shape_chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">subword</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">cutting_shape_chars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">subword</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="ow">or</span> <span class="n">cutting_shape_chars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">subword</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The passed Word and cutting shape chars are not compatible.&quot;</span>
            <span class="p">)</span>
        <span class="n">subword</span> <span class="o">=</span> <span class="n">subword</span><span class="o">.</span><span class="n">word_part</span><span class="p">(</span><span class="n">_sanitized_labels</span><span class="p">(</span><span class="n">subword</span><span class="o">.</span><span class="n">image</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subword</span> <span class="o">=</span> <span class="n">subword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shape_chars</span> <span class="o">=</span> <span class="n">cutting_shape_chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quality</span> <span class="o">=</span> <span class="n">quality</span></div></div>


<div class="viewcode-block" id="CutParser"><a class="viewcode-back" href="../../index.html#hwtools.parser.CutParser">[docs]</a><span class="k">class</span> <span class="nc">CutParser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The class of objects that parse the user&#39;s cut choice.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CutParser.__init__"><a class="viewcode-back" href="../../index.html#hwtools.parser.CutParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">word</span><span class="p">:</span> <span class="n">Word</span><span class="p">,</span>
        <span class="n">cutting_shapes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">cut_positions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">cut_choices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate CutParser.</span>

<span class="sd">        Args:</span>
<span class="sd">            word (Word): The Word beeing cut.</span>
<span class="sd">            cutting_shapes (list[np.ndarray]): The cutting shapes as</span>
<span class="sd">                boolean images of the same shape as Word.image.</span>

<span class="sd">            cut_positions (list[tuple[int,int]]): The coordinate tuples</span>
<span class="sd">                of the centers of the cutting shapes in the form (y,x).</span>
<span class="sd">            cut_choices (list[bool]): The information of which</span>
<span class="sd">                cutting_shapes where chosen. True for chosen, False</span>
<span class="sd">                otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># basic data validation</span>
        <span class="n">reference_shape</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">cutting_shape</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">reference_shape</span>
                <span class="k">for</span> <span class="n">cutting_shape</span> <span class="ow">in</span> <span class="n">cutting_shapes</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Your Word&#39;s image does not have the same&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; shape as every image in cutting_shapes&quot;</span>
            <span class="p">)</span>
        <span class="n">reference_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutting_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">cut_positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reference_length</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_choices</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reference_length</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;All the passed lists do not have the same length.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">word</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutting_shapes</span> <span class="o">=</span> <span class="n">cutting_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span> <span class="o">=</span> <span class="n">cut_positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut_choices</span> <span class="o">=</span> <span class="n">cut_choices</span>

        <span class="k">if</span> <span class="n">cutting_shapes</span><span class="p">:</span>
            <span class="n">shape_vert_proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cutting_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shape_height</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">shape_vert_proj</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">shape_vert_proj</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_height</span> <span class="o">=</span> <span class="n">shape_height</span></div>

<div class="viewcode-block" id="CutParser.subword_from_cutting_position"><a class="viewcode-back" href="../../index.html#hwtools.parser.CutParser.subword_from_cutting_position">[docs]</a>    <span class="k">def</span> <span class="nf">subword_from_cutting_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Word</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the subword between the neighboring tentative cuts.</span>

<span class="sd">        Args:</span>
<span class="sd">            i (int): The index of the considered cut in</span>
<span class="sd">                self.cut_positions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Word: The sought Word, extracted from self.word.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="o">.</span><span class="n">word_part</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">])</span></div>

<div class="viewcode-block" id="CutParser.get_cut_infos"><a class="viewcode-back" href="../../index.html#hwtools.parser.CutParser.get_cut_infos">[docs]</a>    <span class="k">def</span> <span class="nf">get_cut_infos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">CutInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the list of CutInfos from our cut choices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[CutInfo]: The list of CutInfo objects associated</span>
<span class="sd">                cutting self.Word according to self.cut_choices among</span>
<span class="sd">                self.cutting_shapes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cut_infos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">)):</span>
            <span class="n">previous_x</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">relative_cut_chars</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cut_positions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">previous_x</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_height</span><span class="p">,)</span>
            <span class="n">subword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subword_from_cutting_position</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">cut_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">CutInfo</span><span class="p">(</span><span class="n">subword</span><span class="p">,</span> <span class="n">relative_cut_chars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_choices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">cut_infos</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Gaël Cousin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>